//------------------------------------------------
//--- 010 Editor v16.0.1 Binary Template
//
//      File: PVS
//   Authors: Doliman100
//   Version: 0.0 (FM3/5)
//   Purpose: 
//  Category: 
// File Mask: *.pvs
//  ID Bytes: 46 50 56 53, 53 56 50 46
//   History: 
//------------------------------------------------

// 822719A4 CBinaryStream vftable
// 82269784 CMemoryStream vftable
// 83788E50 PVS::PVSData::Serialize
//  83788AC0 PVS::PVSHeader::Serialize

BitfieldSetAutoCheckBox(false);
BitfieldRightToLeft();

// exact version is unknown
const uint32 PVS_UNKNOWN_VERSION_12 = 12; // 12-20
const uint32 PVS_UNKNOWN_VERSION_25 = 25; // 25-34

typedef uint8 Boolean <read=BooleanToString>;

string BooleanToString(uint value) {
    if (value == 1) {
        return "true";
    } else if (value == 0) {
        return "false";
    }
    local string s;
    SPrintf(s, "error (%d)", value);
    return s;
}

typedef struct {
    int length;
    if (length > 0) {
        char data[length];
    } else {
        local char data[];
    }
} String <read=data, write=0>; // std::string

typedef struct {
    float x;
    float y;
    float z;
    float w;
} DirectX_XMVECTOR <read=Str("%g %g %g %g", x, y, z, w)>; // DirectX::XMVECTOR

typedef struct {
    local int i;
    for (i = 0; i < 4; i++) {
        DirectX_XMVECTOR r;
    }
} DirectX_XMMATRIX; // DirectX::XMMATRIX

typedef struct {
    float x;
    float y;
    float z;
} FLOAT3 <read=Str("%g %g %g", x, y, z)>;

typedef struct {
    hfloat x;
    hfloat y;
    hfloat z;
} HFLOAT3 <read=Str("%g %g %g", x, y, z)>;

// PVS3 FM1
// FPVS FM2+

struct PVSHeader {
    // versions
    // 5-11 FM2 (11)
    // 20-24 FM3 (21, 23, 24)
    // 27 FM4 (24, 25, 27)
    //  50 FH1; not match FM5
    //  51 FH2X360
    // 34-50? FM5
    // 60 FH2XO
    // 54-64 FH3
    // 79 FM6Apex
    uint32 magic <format=hex>; // unsigned long; 'FPVS'
    if (magic == 0x53565046) { // reversed magic
        if (IsLittleEndian()) {
            BigEndian();
            BitfieldRightToLeft();
        } else {
            LittleEndian();
        }
    }

    uint32 version; // unsigned long
    if (version > 50) {
        Printf("Warning: Unsupported PVS version. Found: %d. Max supported: 50\n", version);
    }
    if (version < 5) {
        Printf("Warning: Unsupported PVS version. Found: %d. Min supported: 5\n", version);
    }
    if (version >= 11) { // else: unk1 = 0x3500000
        uint32 cpu_data_size; // unsigned long; cpudatasize
    }
    if (header.version >= PVS_UNKNOWN_VERSION_25) {
        uint32 unk2;
    }
} header;

uint16 unk; // unsigned short
uint16 unk; // unsigned short

// FM2/3: 0xFF000000 | (unk & 0xFFFFFF)
// FM5: (unk << 8) | 0xFF
//typedef uint32 PVSTextureRef; // ref to textures array
local uint32 tr_max = 1000;
typedef struct {
    uint32 value;
    //if (tr_max < value) {
    //    tr_max = value;
    //}
    //if (tr_max > value) {
    //    tr_max = value;
    //}
    //if (value == 107) {
    //    Printf("%08X\n", FTell() - 4);
    //}
} PVSTextureRef <optimize=false>;

uint32 zones_length; // unsigned long count;
struct PVSZone {
    if (header.version < 45) {
        uint32 unk1_length;
        uint16 unk1[unk1_length]; // std::vector<TIndex<unsigned short, 18>> numVisibleModelInstances
        
        if (header.version >= PVS_UNKNOWN_VERSION_12) {
            uint32 unk2_length;
            uint16 unk2[unk2_length]; // std::vector<TIndex<unsigned short, 19>>
        }
    } else {
        // TIndex<unsigned long, 20> - PVS::IndexType_PVSZoneVisibleModelInstance
        // TTypedIndexVector<TIndex<unsigned long, 18>, TIndex<unsigned long, 20>> m_ZoneVisibleModelInstances;
        uint32 unk1_length;
        if (unk1_length > 0) {
            uint32 unk1[unk1_length]; // std::vector<TIndex<unsigned long, 18>>
        }

        // TIndex<unsigned long, 21> - PVS::IndexType_PVSZoneVisibleModel
        // TTypedIndexVector<TIndex<unsigned long, 19>, TIndex<unsigned long, 21>> m_ZoneVisibleModels;
        uint32 unk2_length;
        if (unk1_length > 0) {
            uint32 unk2[unk2_length]; // std::vector<TIndex<unsigned long, 19>>
        }
    }

    // TIndex<long, 27> - PVS::IndexType_PVSZoneTexture
    // TTypedIndexVector<PVS::PVSTextureRef, TIndex<long, 27>> m_ZoneTextures;
    uint32 textures_references_length;
    if (textures_references_length > 0) {
        PVSTextureRef textures_references[textures_references_length];
    }
    
    if (header.version >= 8) {
        if (header.version < PVS_UNKNOWN_VERSION_25) {
            uint32 textures_use_length;
            if (textures_use_length > 0) {
                uint8 textures_use[textures_use_length]; // std::vector<unsigned char> m_ZoneTextureUse;
                //struct {
                //    uint8 value; // 0 or 1
                //    if (value > 1) {
                //        Printf("Value > 1\n");
                //    }
                //} textures_use[textures_use_length] <optimize=false>;
            }
        } else {
            // TTypedIndexVector<enum PVS::Quality::Enum, TIndex<long, 27>>
            uint32 textures_quality_length;
            if (textures_quality_length > 0) {
                uint8 textures_quality[textures_quality_length]; // void *
            }
        }
    }
} zones[zones_length] <optimize=false>; // m_PVSZones; FM2: PVS::CZone

if (header.version >= 36) {
    uint32 zones_spans_length;
    struct PVSZoneSpan {
        uint16 unk1; // unsigned short
        uint16 unk2; // unsigned short
        uint32 unk3; // unsigned long
    } zones_spans[zones_spans_length]; // std::vector<PVS::PVSZoneSpan>
}
if (header.version >= 48) {
    Boolean unk1; // bool
}

// TIndex<long, 24> - PVS::IndexType_PVSTexture
// TTypedIndexVector<PVS::PVSTexture, TIndex<long, 24>> m_PVSTextures;
uint32 textures_length; // match _0x00000001.bix+.bin indexes
struct PVSTexture {
    uint32 texture_file_name <format=hex>;
    //if (texture_file_name == 0x2fc) {
    //    Printf("%08X\n", FTell() - 4);
    //}
    uint32 unk2;
    float u_scale; // may be negative. right instead of scale?
    float v_scale;
    float u_translate;
    float v_translate;
    struct {
        uint32 unk1 : 2;
        uint32 separate_base_and_mip_chain : 1; // SeparateBaseAndMipChain
        uint32 unk2 : 1;
        uint32 road_detail : 4; // Flag_RoadDetailMask
        uint32 unk3 : 24;
    } m_Flags; // unsigned long
    if (header.version >= 41) {
        uint16 unk1_v41;
        uint16 unk2_v41;
        uint16 unk3_v41;
        uint16 unk4_v41;
    }
    if (header.version >= 46) {
        uint32 unk1_v46; // unsinged long
        uint8 unk2_v46[4]; // void *
        uint8 unk3_v46[32]; // void *
    }
} textures[textures_length] <optimize=false>;

if (header.version >= PVS_UNKNOWN_VERSION_12) {
    // TTypedIndexVector<PVS::PVSShader, TIndex<unsigned short, 31>>
    uint32 shaders_length;
    struct PVSShader {
        if (header.version >= PVS_UNKNOWN_VERSION_25) {
            uint32 unk1;
        }
        String unk2; // std::string
    } shaders[shaders_length] <optimize=false>;
}

if (header.version >= PVS_UNKNOWN_VERSION_25) {
    // TTypedIndexVector<PVS::PVSMaterial, TIndex<unsigned short, 32>>
    uint32 materials_length;
    struct PVSMaterial {
        uint32 unk1;
        String unk2; // std::string
    } materials;
    
    // TTypedIndexVector<PVS::PVSModelInstanceMaterialLighting, TIndex<unsigned short, 34>>
    uint32 model_instance_material_lighting_length;
    struct PVSModelInstanceMaterialLighting {
        // std::map<std::string, PVS::PVSMaterialOverride>
        uint32 material_override_map_length;
        if (material_override_map_length > 0) {
            struct {
                String unk1; // key?
                
                // value?
                String unk2;
                uint32 unk3_length;
                uint8 unk3[unk3_length]; // void *
    
                // std::vector<PVS::PVSMaterialOverride::MaterialOverrideTexture>
                // ...
            } material_override_map; // [material_override_map_length]
        }
    
        // std::vector<PVS::PVSModelInstanceLightingData>
        uint32 model_instance_lighting_data_length;
        struct PVSModelInstanceLightingData {
            uint32 lighting_data_length;
            struct PVSLightingData {
                if (header.version < 37) {
                    // TODO
                } else {
                    // IOSys::SerializeEnumKeyMap<std::map<enum PVS::PVSLightingData::LightScenarioTextureType::Enum,PVS::PVSLightingData::LightingTextureData>,unsigned char>
                    uint32 unk1_length;
                    struct {
                        uint8 unk1; // unsigned char
                        uint32 unk2; // unsigned long
                        uint16 unk3; // unsigned short
                    } unk1[unk1_length];
                }
            } lighting_data[lighting_data_length] <optimize=false>;
        } model_instance_lighting_data[model_instance_lighting_data_length] <optimize=false>;
    } model_instance_material_lighting[model_instance_material_lighting_length] <optimize=false>;
}

typedef struct {
    if (header.version < 45) {
        int16 model_index; // unsigned short; refers to models array
        //Printf("%d\n", model_index);
        //if (model_index == 49 || model_index == 1030 || model_index == 809) {
        //    Printf("%08X\n", FTell() - 2);
        //}
    } else {
        uint32 model_index;
    }
	if (header.version < 22) {
		 DirectX_XMVECTOR unk13;
		 DirectX_XMMATRIX unk14;
	}
    if (header.version < 36) {
        uint32 unk2; // flags?
    } else {
        uint64 unk2; // unsigned __int64
    }
    if (header.version < PVS_UNKNOWN_VERSION_25) {
	    PVSTextureRef texture_reference;
	    int32 unk4; // long
	    float unk5;
	    if (header.version < 22) {
            float unk15;
            float unk16;
            float unk17;
	    }
	    if (header.version >= 21) {
		    uint16 unk6;
	    }
	    if (header.version >= 22) {
		    hfloat unk7;
		    hfloat unk8;
		    hfloat unk9;
        }
    } else {
        uint16 unk3;
        uint16 unk4;
        uint16 unk5;
        uint16 unk6;
        uint16 unk7;
        uint16 unk8;
    }
    if (header.version >= 39) {
        uint16 unk1_v39; // unsigned short
    }
    if (header.version >= 42) {
        uint8 unk1_v42; // unsigned char
    }
	if (header.version >= 22) {
        FLOAT3 translate;
        struct {
            HFLOAT3 r;
            HFLOAT3 r;
            HFLOAT3 r;
        } transform;
	}
    if (header.version >= 44) {
        DirectX_XMVECTOR unk1_v44; // DirectX::XMVECTOR
    }
} PVSModelInstance;

typedef struct {
    //TTypedIndexVector<PVS::PVSTextureRef, TIndex<long, 27>>
    uint32 textures_references_length;
    if (textures_references_length > 0) {
        PVSTextureRef textures_references[textures_references_length];
    }

    if (header.version < PVS_UNKNOWN_VERSION_25) {
	    uint32 shaders_indexes_length;
        if (shaders_indexes_length > 0) {
	     uint32 shaders_indexes[shaders_indexes_length];
        }
    } else {
        Boolean unk1; // bool
    }
    DirectX_XMMATRIX transform; // DirectX::XMMATRIX
    DirectX_XMVECTOR translate; // DirectX::XMVECTOR
    if (header.version >= PVS_UNKNOWN_VERSION_25) {
        struct {
            if (header.version < 45) {
                uint16 unk1;
            } else {
                uint32 unk1;
            }
        } unk4[header.version < 39 ? 3 : 4] <optimize=false>;
    }
    if (header.version >= 47) {
        Boolean unk1_v47;
        Boolean unk2_v47;
        Boolean unk3_v47;
        Boolean unk4_v47;
        Boolean unk5_v47;
        uint16 unk6_v47;
        uint16 unk7_v47;
    }
} PVSModel;

typedef struct {
    uint32 textures_references_length;
    if (textures_references_length > 0) {
        PVSTextureRef textures_references[textures_references_length];
    }
    if (header.version >= 6) {
        uint32 unk1_v6; // unsigned long
    }
    if (header.version >= 7) { // else: unk1_v7=1,1,1; unk2_v7=0,0,0
        DirectX_XMVECTOR unk1_v7;
        DirectX_XMVECTOR unk2_v7;
    }
    if (header.version >= 9) {
        DirectX_XMVECTOR unk1_v9;
    }
} CMesh; // PVS::CMesh; PVSModelInstance and PVSModel

if (header.version < PVS_UNKNOWN_VERSION_12) {
    uint32 meshes_length; // match testtrackinfieldout.00000.rmb.bin indexes
    CMesh meshes[meshes_length] <optimize=false>;
}
if (header.version < 9) {
    uint32 meshes_2_length;
    CMesh meshes_2[meshes_2_length];
    uint32 unk1_length;
    uint16 unk1[unk1_length]; // unsigned short
}
if (header.version < PVS_UNKNOWN_VERSION_12) {
    CMesh mesh1;
    CMesh mesh2;
}

if (header.version >= PVS_UNKNOWN_VERSION_12) {
    // TIndex<unsigned long, 18> - PVS::IndexType_PVSModelInstance
    // TTypedIndexVector<PVS::PVSModelInstance, TIndex<unsigned long, 18>> m_PVSModelInstances;
    uint32 models_instances_length;
    PVSModelInstance models_instances[models_instances_length] <optimize=false>;
    
    // TIndex<unsigned long, 19> - PVS::IndexType_PVSModel
    // TTypedIndexVector<PVS::PVSModel, TIndex<unsigned long, 19>> m_PVSModels;
    uint32 models_length;
    PVSModel models[models_length] <optimize=false>;
}

if (header.version >= 35) {
    // TTypedIndexVector<PVS::PVSCubemapProbe, TIndex<long, 3>>
    uint32 cubemap_probes_length;
    struct PVSCubemapProbe {
        String unk1;
        DirectX_XMVECTOR unk2;
        Boolean unk3; // bool
        if (header.version >= 40) {
            int32 unk1_v40; // long
            int32 unk2_v40; // long
        }
        if (header.version >= 43) {
            Boolean unk1_v43; // bool
        }
        if (header.version >= 50) {
            Boolean unk1_v50; // bool
        }
    } cubemap_probes;
}

if (header.version < PVS_UNKNOWN_VERSION_25) {
    if (header.version >= PVS_UNKNOWN_VERSION_12) {
        PVSModelInstance model_instance_2;
        PVSModel model_2;
    }
} else if (header.version < 45) {
    uint32 unk1_length;
    uint16 unk1[unk1_length]; // std::vector<TIndex<unsigned short, 18>>

    uint32 unk2_length;
    uint16 unk2[unk2_length]; // std::vector<TIndex<unsigned short, 19>>

    uint32 unk3_length;
    uint16 unk3[unk3_length]; // std::vector<TIndex<unsigned short, 19>>
} else {
    // TTypedIndexVector<TIndex<unsigned long, 18>, TIndex<unsigned short, 28>>
    uint32 unk1_length;
    if (unk1_length > 0) {
        uint32 unk1[unk1_length];
    }

    // TTypedIndexVector<TIndex<unsigned long, 19>, TIndex<unsigned short, 28>>
    uint32 unk2_length;
    if (unk2_length > 0) {
        uint32 unk2[unk2_length];
    }

    // TTypedIndexVector<TIndex<unsigned long, 19>, TIndex<unsigned short, 29>>
    uint32 unk3_length;
    if (unk3_length > 0) {
        uint32 unk3[unk3_length];
    }
}

if (header.version >= PVS_UNKNOWN_VERSION_12) {
    // TTypedIndexVector<PVS::PVSModelInstance, TIndex<unsigned long, 18>> m_PVSLoneModelInstances;
    uint32 lone_models_instances_length;
    if (lone_models_instances_length > 0) {
        PVSModelInstance lone_models_instances[lone_models_instances_length] <optimize=false>;
    }
}

String name; // IOSys::SerializeContainer<std::string>

if (header.version < 9) {
    uint32 unk17_length;
    uint32 unk17[unk17_length]; // unsigned long
}

Boolean unk4;

if (header.version >= PVS_UNKNOWN_VERSION_12) {
    Boolean unk5;
}

if (header.version > 21) { // may be unk6 fields related instead
    // TIndex<unsigned short, 23> - PVS::IndexType_PVSObjectID
    // TTypedIndexVector<std::string, TIndex<unsigned short, 23>> m_PVSObjectIDList;
    uint32 unk6_length;
    if (unk6_length > 0) {
        Printf("New field found. Please, report this file.\n");
        String unk6[unk6_length];
    }
}

if (header.version >= PVS_UNKNOWN_VERSION_25) {
    // TIndex<unsigned short, 35> - PVS::IndexType_PVSStateMachineID
    // TTypedIndexVector<std::string, TIndex<unsigned short, 35>> m_StateMachineIDList;
    uint32 unk7_length;
    if (unk7_length > 0) {
        Printf("New field found. Please, report this file.\n");
        String unk7[unk7_length];
    }
}

if (header.version < 49) {
    //TODO
} else {
    // TIndex<unsigned short, 36> - PVS::IndexType_PVSStateMachineInstance
    // TTypedIndexVector<PVS::PVSStateMachineInstance, TIndex<unsigned short, 36>> m_StateMachineInstanceList;
    uint32 state_machine_instances_length;
    if (state_machine_instances_length > 0) {
        struct PVSStateMachineInstance {
            uint16 unk1;
            uint16 unk2;
            uint16 unk3;
        } state_machine_instances[state_machine_instances_length];
    }

    // TIndex<unsigned short, 37> - PVS::IndexType_PVSAnimationEntity
    // TTypedIndexVector<PVS::PVSAnimationEntity, TIndex<unsigned short, 37>> m_AnimationEntityList;
    uint32 animation_entities_length;
    if (animation_entities_length > 0) {
        struct PVSAnimationEntity {
            int32 unk1; // long
            uint16 unk2;
            Boolean unk3; // bool
        } animation_entities[animation_entities_length];
    }
}

if (header.version >= 23) {
    uint32 zones_visibility_length;
    struct PVSZoneVisibility {
        // TTypedIndexVector<PVS::PVSZoneVisibleModelInstanceVisibility, TIndex<unsigned long, 20>>
        uint32 models_instances_visibility_length;
        if (models_instances_visibility_length > 0) {
            uint16 models_instancse_visibility[models_instances_visibility_length]; // std::vector<PVS::PVSZoneVisibleModelInstanceVisibility> m_ZoneVisibleModelInstanceVisibility;
        }
    } zones_visibility[zones_visibility_length] <optimize=false>; // std::vector<PVS::PVSZoneVisibility> m_PVSZoneVisibility;
}

if (header.version >= PVS_UNKNOWN_VERSION_25) {
    uint32 unk8_length;
    struct {
        uint32 key; // unsigned long
        int32 value; // long; TIndex<long, 24>
    } unk8[unk8_length]; // std::map<unsigned long, TIndex<long, 24>>
    
    Boolean unk9; // bool
    if (unk9) {
        // TODO
    }
}

//Printf("%d\n", tr_max);
